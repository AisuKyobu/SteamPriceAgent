from langchain.agents import create_agent
from langchain_community.utilities import SearxSearchWrapper
import requests
import os

import streamlit as st

from config.settings import settings

searxSearch = SearxSearchWrapper(searx_host="http://127.0.0.1:8888",k=10)

def internet_search(query: str):
    """Run a web search"""
    return searxSearch.run(query,engines=["baidu","wiki","bing","sogou","quark"])

def get_game_id_from_isthereanydeal(game_name: str):
    """
    从 isthereanydeal API 获取游戏的 ID 和名称（支持返回多个结果）。

    参数:
    - game_name (str): 游戏名称。

    返回:
    - list[dict]: 包含游戏名称和 ID 的列表，例如 [{"title": "Game1", "id": "id1"}, {"title": "Game2", "id": "id2"}]。

    异常:
    - ConnectionError: 如果 API 请求失败。
    """
    api_key = settings.get_itad_api_key
    url = f"https://api.isthereanydeal.com/games/search/v1?key={api_key}&title={game_name}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if data:
            return [{"title": game["title"], "id": game["id"]} for game in data]
        else:
            return "未查询对应的游戏名称。请确认游戏名称是否正确，或者游戏是否已发售。"
    else:
        raise ConnectionError(f"获取游戏 ID 失败，状态码: {response.status_code}")

def get_historical_low_price(game_ids: list[dict]):
    """
    根据多个游戏 ID 从 isthereanydeal API 获取游戏的当前价格、折扣力度和史低价格。

    参数:
    - game_ids (list[dict]): 包含游戏名称和 ID 的列表，例如 [{"title": "Game1", "id": "id1"}, {"title": "Game2", "id": "id2"}]。

    返回:
    - list[dict]: 包含每个游戏的查询结果，例如：
      [
        {
          "title": "Game1",
          "current_price": 100,
          "current_discount": "5",(5折)
          "lowest_price": 50,
          "lowest_discount": "10",(10为没有折扣)
          "regular_price": 200
        },
        ...
      ]

    异常:
    - ValueError: 如果未找到价格数据。
    - ConnectionError: 如果 API 请求失败。
    """
    api_key = settings.get_itad_api_key
    url = f"https://api.isthereanydeal.com/games/overview/v2?key={api_key}&country=CN&shops=61"
    ids = [game["id"] for game in game_ids]
    response = requests.post(url, json = ids)
    if response.status_code == 200:
        data = response.json()
        if "prices" in data and data["prices"]:
            results = []
            for game in game_ids:
                game_id = game["id"]
                game_title = game["title"]
                price_data = next((p for p in data["prices"] if p["id"] == game_id), None)
                if price_data:
                    current_price = price_data["current"]["price"]["amount"]
                    regular_price = price_data["current"]["regular"]["amount"]
                    current_cut = price_data["current"]["cut"]
                    current_discount = f"{int(10 - current_cut / 10)}折"
                    lowest_price = price_data["lowest"]["price"]["amount"]
                    lowest_cut = price_data["lowest"]["cut"]
                    lowest_discount = f"{int(10 - lowest_cut / 10)}折"
                    results.append({
                        "title": game_title,
                        "current_price": current_price,
                        "current_discount": current_discount,
                        "lowest_price": lowest_price,
                        "lowest_discount": lowest_discount,
                        "regular_price": regular_price
                    })
            return results
        else:
            return "未找到对应游戏的价格数据。如果已查询到游戏ID，请确认游戏是否已发售。"
    else:
        raise ConnectionError(f"获取史低价格失败，状态码: {response.status_code}, 响应内容: {response.text}")

research_instructions = """
你是一个Steam游戏史低查询员。你的任务是告诉用户游戏目前的价格以及史低的价格，
目前是否打折,打折的话是几折。
    
你可以使用以下工具：
- internet_search: 搜索引擎工具,用于搜索游戏的steam名称,判断游戏是否发售以及是否存在
- get_game_id_from_isthereanydeal: 用于从 isthereanydeal API 根据游戏名称的模糊匹配获取游戏的 ID 和名称（支持返回多个结果）
- get_historical_low_price: 用于根据游戏 ID(支持同时查询多个游戏id) 获取游戏的当前价格、折扣力度和史低价格
    
请确保：
1. 进行搜索来收集游戏信息,确定steam上的正确名称,判断游戏是否发售以及是否存在
2. 正确的使用 isthereanydeal API 来获取价格信息
3. 提供清晰简洁的回答,在无折扣时直接说明无折扣不提示折扣力度
"""

agent = create_agent(
    model="deepseek:deepseek-chat",
    tools=[internet_search, get_game_id_from_isthereanydeal, get_historical_low_price],
    system_prompt=research_instructions
)

# for event in agent.stream(
#     {"messages":[{"role": "user", 
#     "content": "巫师三和赛博朋克的价格是多少?"}]
#     },
#     stream_mode="values"
# ):
#     event["messages"][-1].pretty_print()



st.title("Steam史低查询Bot")

# --- 状态初始化 ---
if 'input_disabled' not in st.session_state:
    st.session_state.input_disabled = False
# 状态优化：将待处理消息存储为一个键，而不是 None，避免混淆
if 'prompt_to_process' not in st.session_state:
    st.session_state.prompt_to_process = "" 

if "messages" not in st.session_state:
    st.session_state.messages = [{
        "role": "assistant", 
        "content": "你好！我是你的Steam史低查询助手。有什么游戏想要查询的吗？"
    }]
# --- 状态初始化结束 ---


# 显示消息历史
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])
        
# 渲染输入框
input = st.chat_input("有什么想查询的游戏吗?", disabled=st.session_state.input_disabled)

if prompt := input:
    # 1. 记录用户消息并保存到历史
    st.session_state.messages.append({"role": "user", "content": prompt})
    
    # 2. 标记需要处理的消息，并禁用输入框
    st.session_state.prompt_to_process = prompt 
    st.session_state.input_disabled = True
    
    # 3. 立即刷新，让输入框禁用状态生效
    st.rerun()

if st.session_state.input_disabled and st.session_state.prompt_to_process:
    
    # 4. 显示“bot思考中”提示
    with st.chat_message("assistant"):
        thinking_message = st.empty()  # 创建一个占位符
        thinking_message.markdown("bot思考中...")  # 显示“bot思考中”
        
        # 5. 调用 AGENT 获取响应
        try:
            response = agent.invoke({"messages": st.session_state.messages}, stream_mode="values")['messages'][-1].content
        except Exception as e:
            response = f"抱歉，我遇到了一些问题：{str(e)}"

        # 6. 更新“bot思考中”提示为实际响应
        thinking_message.markdown(response)

    # 7. 将 AI 响应添加到消息历史
    st.session_state.messages.append({"role": "assistant", "content": response})
    
    # 8. 清除待处理标记，并启用输入框
    st.session_state.prompt_to_process = "" # 关键：清除标记，阻止下次循环运行此块
    st.session_state.input_disabled = False 
    
    # 9. 再次刷新，让输入框启用状态生效
    st.rerun()